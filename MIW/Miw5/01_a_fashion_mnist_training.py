# -*- coding: utf-8 -*-
"""01_a_fashion_mnist_training.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oHeOhPrE6NQ0hniXSJC66reMm1Wj61bP
"""

import numpy as np
import keras
import matplotlib.pyplot as plt
from keras.models import Model
from keras.layers import Input, Dense, Flatten, Conv2D, MaxPooling2D, Dropout
from keras.utils import plot_model
from keras.datasets import fashion_mnist

# Definicja etykiet klas
labels = ["T-shirt/top","Spodnie","Sweter","Sukienka","Płaszcz","Sandał","Koszula","Sneaker","Torebka","but"]

# Załaduj dane
(x_train,y_train), (x_test, y_test) = fashion_mnist.load_data()
# podgląd
print("etykieta ",labels[y_train[0]])
plt.imshow(x_train[0], cmap='gray')

# Przetwórz dane
# Dane typu float32, modele często lepiej radzą sobie z danymi liczbowymi w formie zmiennoprzecinkowej.
# Normalizujemy dane do przedziału [0, 1]
x_train = x_train.astype('float32') / 255
x_test = x_test.astype('float32') / 255

# Konwertuj etykiety na kategorie
# kodowanie kategoryczne (one-hot encoding) na zbiorze etykiet treningowych
# zamienia etykiety klas na postać binarną w formie wektorów zer i jedynek
# 3 -> [0. 0. 0. 1. 0. 0. 0. 0. 0. 0.]
num_classes = 10
y_train = keras.utils.to_categorical(y_train, num_classes)
y_test = keras.utils.to_categorical(y_test, num_classes)

# Zdefiniuj model za pomocą Functional API
# Conv2D(liczba filtrów,...)
input_shape=(28,28,1)
inputs = Input(shape=input_shape)
x = Conv2D(32, (3, 3), activation='relu', kernel_initializer='he_uniform', padding='same')(inputs)
x = Conv2D(32, (3, 3), activation='relu', kernel_initializer='he_uniform', padding='same')(x)
x = MaxPooling2D((2, 2))(x)
x = Dropout(0.2)(x)

x = Conv2D(64, (3, 3), activation='relu', kernel_initializer='he_uniform', padding='same')(x)
x = Conv2D(64, (3, 3), activation='relu', kernel_initializer='he_uniform', padding='same')(x)
x = MaxPooling2D((2, 2))(x)
x = Dropout(0.3)(x)

x = Conv2D(128, (3, 3), activation='relu', kernel_initializer='he_uniform', padding='same')(x)
x = Conv2D(128, (3, 3), activation='relu', kernel_initializer='he_uniform', padding='same')(x)
x = MaxPooling2D((2, 2))(x)
x = Dropout(0.4)(x)

x = Flatten()(x)
x = Dense(128, activation='relu', kernel_initializer='he_uniform')(x)
x = Dropout(0.5)(x)
outputs = Dense(num_classes, activation='softmax')(x)

model = Model(inputs=inputs, outputs=outputs)


# Skompiluj model
# 'categorical_crossentropy' średnia z logarytmu przewidywanych prawdopodobieństw dla prawdziwej klasy
# Optymalizator Adam (Adaptive Moment Estimation) wykorzystuje adaptacyjne momenty gradientu do efektywnego dostosowywania wag modelu podczas treningu
model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])
# Trenuj model
# batch_size liczba próbek treningowych użytych do jednej aktualizacji wag modelu podczas jednej iteracji treningowej
history = model.fit(x_train, y_train, batch_size=1000, epochs=3, verbose='auto', validation_data=(x_test, y_test))

import pandas as pd
# Tworzenie wykresu z historią
df = pd.DataFrame(history.history)
ax = df.plot()
# Zapisywanie wykresu do pliku
fig = ax.get_figure()
fig.savefig('history_plot.png')

# Ocena modelu
loss, accuracy = model.evaluate(x_test, y_test, verbose='auto')
print('Test loss:', loss)
print('Test accuracy:', accuracy)

# Wizualizacja modelu
model.summary()
plot_model(model, to_file='model_plot.png', show_shapes=True, show_layer_names=True)

# export modelu CNN
model.save("my_model_fashion_mnist.keras")

# Wyświetlanie przykładów źle sklasyfikowanych
predictions = np.argmax(model.predict(x_test), axis=1);
y_test_flat = np.argmax(y_test, axis=1);
incorrect_indices = np.nonzero(predictions != y_test_flat)[0]

for i in range(5):
    idx = incorrect_indices[i]
    print("Przykład źle sklasyfikowany nr", i+1)
    plt.imshow(x_test[idx].reshape(28, 28), cmap='gray')
    plt.xlabel(f"True label:  {labels[y_test_flat[idx]]}, Predicted label:  {labels[predictions[idx]]}")
    plt.show()

# Visualisation
from sklearn.metrics import ConfusionMatrixDisplay, confusion_matrix

# Tworzenie macierzy pomyłek
cm = confusion_matrix(y_test_flat, predictions)
disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=labels)

# Tworzenie wykresu
fig, ax = plt.subplots(figsize=(10, 10))
disp = disp.plot(xticks_rotation='vertical', ax=ax, cmap='summer')

# Zapisywanie wykresu do pliku
plt.savefig('confusion_matrix.png')
plt.show()